'POMaint'.maint({panelStyle: "titled", icon: 'PeopleArrows'})
'Add Purchase Order'.title({when: 'adding'})
'Edit Purchase Order'.title({when: 'editing'})
'Back'.action({act: 'cancel'})
'OK'.action({act: 'ok'})
'Save'.action({act: 'save'})
'Send Via Email'.action()
'View Receipts'.action({spec: 'ViewPOReceipts.js'})
'Payments'.action({spec: 'Payments.js'})
'Download PDF'.action()
'Download CSV'.action()
'Attachments'.action({act: 'attachments'})
'Transitions'.action({spec: 'TransitionList.js'})
'Add another'.action({act: 'add'})
'PO'.datatype({caption: 'Purchase Order'})

'Order Summary'.panel()
'purchaseOrderNumber'.field({key: true})
'orderDate'.field({date: true})
'supplier'.field({refersTo: 'Supplier'})
'supplierFullAddress'.field({caption: 'Supplier Address', hidden: true})
'supplierReference'.field({caption: 'Supplier Invoice No or Reference'})
'expectedDeliveryDate'.field({date: true})
'overdueDays'.field({numeric: true, hidden: true})
'stage'.field()
'so'.field({refersTo: 'SO', caption: 'Sales Order', readOnly: true, indexed: true})
'includeTaxOption'.field({yesOrNo: true, hidden: true})
'pdfTitle'.field({hidden: true})
'pdfLogo'.field({image: true, hidden: true})
'businessName'.field({hidden: true})
'hasSeparateDeliveryLines'.field({yesOrNo: true, hidden: true})
'autoGeneratedReceipt'.field({yesOrNo: true, hidden: true})
'emailed'.field({yesOrNo: true, hidden: true})
'emailAddress'.field({readOnly: true})
'emailDate'.field({date: true, readOnly: true, allowEmpty: true})

'Delivery Details'.panel()
'deliverTo'.field()
'ourContactDetails'.field()
'location'.field({refersTo: 'Location', allowEmpty: false})
'carrier'.field()
'trackingNumber'.field({caption: "Tracking#"})
'billOfLadingNumber'.field({caption: "BOL#"})
'notesForSupplier'.field({multiLine: true})
'status'.field({refersTo: 'POStatus', readOnly: true, translateOnDisplay: true})
'receivedDate'.field({date: true, readOnly: true})
'dateOfLastReceiptFromThisSupplier'.field({date: true, readOnly: true})

'Amounts'.panel()
'supplierCurrency2'.field({hidden: true})
'currency'.field({refersTo: 'Currency'})
'exchangeRate'.field({numeric: true, minDecimals: 4})
'costIncTax'.field({numeric: true, decimals: 2, hidden: true, caption: "Order Total (Inc Tax)"})
'costExclTax'.field({numeric: true, decimals: 2, hidden: true, caption: "Order Total (Excl Tax)"})
'costIncTaxFX'.field({numeric: true, decimals: 2, readOnly: true, caption: "Order Total (Inc Tax)"})
'costExclTaxFX'.field({numeric: true, decimals: 2, hidden: true, caption: "Order Total (Excl Tax)"})
'costIncTaxFXWithCurrency'.field({hidden: true, caption: "Order Total (Inc Tax)"})
'tax'.field({numeric: true, decimals: 2, hidden: true})
'taxFX'.field({numeric: true, decimals: 2, readOnly: true, caption: "Tax"})

'Payment'.panel()
'paymentTerms'.field({multiLine: true})
'paymentStatus'.field()
'amountOutstandingFX'.field({numeric: true, decimals: 2, readOnly: true, caption: 'Amount Outstanding'})
'paymentDueDate'.field({date: true, allowEmpty: true})
'daysUntilPaymentDue'.field({numeric: true, readOnly: true})

'journaledPaymentAmount'.field({numeric: true, decimals: 2, hidden: true, preserveOnTrash: true})
'journaledPaymentLocation'.field({refersTo: 'Location', hidden: true})
'journaledDate'.field({date: true, allowEmpty: true, hidden: true})
'hasEmbryoLines'.field({yesOrNo: true, hidden: true})

'Lines'.manifest()
'Add Line'.action({act: 'add'})
'Auto Lines - Min-Max'.action()
'Bulk Add'.action()
'Add Sales Order Lines'.action()
'POLine'.datatype()
'thumbnailImage'.field()
'descriptionAndSKU'.field({showAsLink: true, readOnly: true})
'sku'.field({readOnly: true})
'supplierSku'.field({readOnly: true})
'embryoNotes'.field({readOnly: true})
'quantityPU'.field({readOnly: false, caption: 'Purch Unit Qty'})
'uomDisplay'.field({readOnly: true, caption: 'UOM'})
'quantity'.field({readOnly: false})
'unitCostIncTaxFX'.field({readOnly: false})
'unitCostExclTaxFX'.field({readOnly: false})
'lineCostExclTaxFX'.field({readOnly: true})
'lineCostIncTaxFX'.field({readOnly: true})
'priorWeeksSalesUnits'.field({readOnly: true})
'priorWeeksSalesValue'.field({readOnly: true, caption: 'Sales Value'})
'separateDelivery'.field({tickbox: true, readOnly: false})
'lineExpectedDeliveryDate'.field({readOnly: false})
//'priorSemiRecentWeeksSalesUnits'.field({readOnly: true})
//'priorRecentWeeksSalesUnits'.field({readOnly: true})
//'ETA'.action({place: 'row'})
'Edit'.action({place: 'row', act: 'edit'})
'Trash'.action({place: 'row', act: 'trash'})
'POLineMaint.js'.maintSpecname()

/* eslint-disable no-cond-assign */

'paymentTerms'.default(async po => {
  return global.confVal('pte')
})

'paymentTerms'.visibleWhen((maint, po) => {
  return global.confVal('spt') === 'Yes'
})

'hasEmbryoLines'.calculate(async po => {
  if ( global.confVal('emb') !== 'Yes' ) return false
  return (await po.doHasEmbryoLines()) ? 'Yes': 'No'
})

'embryoNotes'.columnVisibleWhen((list, po) => {
  return po.hasEmbryoLines === 'Yes'
})

'PO'.method('doHasEmbryoLines', async function() {
  let line; let lines = await this.toPOLines()
  while ( line = lines.__() ) {
    if ( line.embryoNotes ) return true
  }
  return false
})

'Transitions'.availableWhen(po => {
  return global.confVal('ptr') === 'Yes'
})

'emailAddress'.visibleWhen((maint, po) => {
  return po.emailed === 'Yes'
})

'emailDate'.visibleWhen((maint, po) => {
  return po.emailed === 'Yes'
})

'Send Via Email'.act(async (maint, po) => {
  try {
    await po.sendViaEmail()
    maint.showMessage("Email was sent")
  } catch(e) {
    maint.showMessage("There was a problem sending the email:".translate() + " " + e.message)
    await global.foreman.doSave()
  }
})

'PO'.method('createPDFAttachment', async function() {
  let pdf = await global.app.generatePDF(this, {spec: 'POPdf.js'}); if ( ! pdf ) return
  let attachment = await 'Attachment'.create()
  attachment.datatype = 'PO'
  attachment.theParentId = this.id
  await attachment.refreshEntityName()
  attachment.parentReference = this.purchaseOrderNumber
  attachment.attachmentType = 'Other'
  attachment.description = 'Purchase Order PDF ' + this.purchaseOrderNumber
  attachment.attachedDate = global.todayYMD()
  attachment.documentType = 'PDF'
  attachment.contents = btoa(pdf.output())
  let fileName = attachment.description + '.PDF'
  attachment.__fileName = fileName
  attachment.fileName = fileName
  await global.foreman.doSave()
  return attachment
})

'PO'.method('sendViaEmail', async function() {
  await global.foreman.doSave()
  let attachment = await this.createPDFAttachment(); if ( ! attachment ) throw(new Error('Unable to create PDF attachment'.translate()))
  await this.refreshEmailAddress(); if ( ! this.emailAddress ) throw(new Error('The ordering email address has not been set up for this supplier'.translate()))
  await global.foreman.doSave()
  let businessName = global.confVal('businessName')
  await global.server.emailAttachment(
    {
      attachment: attachment,
      emailAddress: this.emailAddress,
      subject: businessName + ' ' + 'Purchase Order'.translate() + ' ' + this.purchaseOrderNumber,
      message: 'Please find attached Purchase Order'.translate() + ' ' + this.purchaseOrderNumber
    }
  )
  this.emailed = 'Yes'
  this.emailDate = global.todayYMD()
  await global.foreman.doSave()
})

'PO'.method('refreshEmailAddress', async function() {
  this.emailAddress = null
  let supplier = await this.toSupplier(); if ( ! supplier ) return
  this.emailAddress = supplier.orderingEmail
})

'PO'.method('updateSO', async function() {
  let so = await this.referee('so'); if ( ! so ) return
  await so.refreshDrop()
})

'PO'.method('generatePOReceipt', async function(opt) {

  let generateReceiptNumber = async () => {
    let recToSuffix = (aRec) => {
      let no = aRec.receiptNumber
      let parts = no.split('-')
      if ( parts.length < 2 ) return "00"
      return parts[parts.length - 1]
    }
  
    let incSuffix = (aSuffix) => {
      let no = Number(aSuffix) + 1 + ""
      return no.padStart(2, '0')
    }

    let recsToOneWithMaxReceiptNumber = (aRecs) => {
      let res
      let max = ''
      aRecs.forAll(rec => {
        let no = rec.receiptNumber; if ( ! no ) return 'continue'
        if ( no <= max ) return 'continue'
        max = no
        res = rec
      })
      return res
    }
  
    let poNo = this.purchaseOrderNumber
    let recs = await 'POReceipt'.bring({purchaseOrder: this.reference()})
    let rec = recsToOneWithMaxReceiptNumber(recs)
    let suffix = "01"
    if ( rec ) {
      suffix = recToSuffix(rec)
      suffix = incSuffix(suffix)
    }
    let recNo = poNo + "-" + suffix
    return recNo
  }

  let createLines = async () => {
    let poLines = await this.toPOLines()
    await poLines.forAllAsync(async poLine => {
      let recLine = await 'POReceiptLine'.create({parentCast: poReceipt}, {poReceipt: poReceipt.reference(), poLine: poLine.reference()})
      recLine.product = poLine.product
      recLine.unitCostFX = poLine.unitCostIncTaxFX
      recLine.unitCostExclTaxFX = poLine.unitCostExclTaxFX
      recLine.uom = global.copyObj(poLine.uom)
      await recLine.refreshDependentFields()
      await recLine.refreshCalculations({force: true, includeDefers: true})
      let outstanding = poLine.quantity - recLine.previouslyReceived - poLine.cancelledQuantity
      recLine.receivedQuantity = outstanding
      if ( outstanding === 0 ) {
        await recLine.trash()
        return 'continue'
      }
      await recLine.refreshReceivedQuantityPU()
      await recLine.defaultUnbundle()
      if ( recLine.hasLots === 'Yes' )
        await recLine.createAllotments()
    })
    await poReceipt.refreshAllShippingUnitCosts()
  }

  let defaultFromPO = async () => {
    let po = this
    poReceipt.supplier = global.copyObj(po.supplier)
    poReceipt.receivedDate = po ? po.orderDate : global.todayYMD()
    poReceipt.exchangeRate = po ? po.exchangeRate : 1
    if ( ! poReceipt.exchangeRate )
      poReceipt.exchangeRate = 1
    if ( po ) {
      poReceipt.carrier = po.carrier
      poReceipt.trackingNumber = po.trackingNumber
    }
  }

  let poLines = await this.toPOLines()
  if ( poLines.length === 0 )
    return
  if ( this.autoGeneratedReceipt === 'Yes' )
    return
  this.autoGeneratedReceipt = 'Yes'
  let receiptNumber = await generateReceiptNumber()
  let poReceipt = await 'POReceipt'.create(null, {receiptNumber: receiptNumber, purchaseOrder: this.reference()})
  await defaultFromPO()
  await createLines()
  return poReceipt
})

'Add Sales Order Lines'.act(async (maint, po) => {

  let convertToPU = (inv, qty) => {
    let ratio = inv.quantityPerPurchasingUOM; if ( ! ratio ) return qty
    return Math.ceil(qty / ratio)
  }

  if ( ! po.supplier ) {
    maint.showMessage("Please select a Supplier before adding Sales Order lines")
    return
  }
  if ( await po.hasLines() ) {
    maint.showMessage("This Purchase Order already has lines")
    return
  }
  let so = await po.referee('so'); if ( ! so ) return
  let currency = await po.toCurrency()
  let soLines = await so.getLines()
  for ( var i = 0; i < soLines.length; i++ ) {
    let soLine = soLines[i]
    let qty = soLine.quantityRemainingToShip; if ( qty === 0 ) continue
    //let poLine = await maint.addChildCast()
    let poLine = await 'POLine'.create({parentCast: po}, {purchaseOrder: po.reference(), soLine: soLine.reference()})
    let inv = await soLine.toInventory()
    poLine.product = inv.product
    poLine.description = inv.productName
    poLine.taxPct = global.confVal('taxPct')
    let cost = await inv.getDefaultPurchaseUnitCostIncTax()
    if ( poLine.includeTaxOption === 'Yes' ) {
      poLine.unitCostIncTaxFX = await global.localAmountToForeign(cost, currency)
      poLine.unitCostIncTaxFX = global.roundTo2Decimals(poLine.unitCostIncTaxFX)
    } else {
      let costExclTax = cost / ( 1 + (poLine.taxPct / 100) )
      poLine.unitCostExclTaxFX = await global.localAmountToForeign(costExclTax, currency)
      poLine.unitCostExclTaxFX = global.roundTo2Decimals(poLine.unitCostExclTaxFX)
    }
    poLine.quantity = qty
    poLine.uom = global.copyObj(inv.purchasingUOM)
    //poLine.soLine = soLine.reference()
    await poLine.refreshCalculations({force: true, includeDefers: true})
    if ( poLine.purchasingUOMDiffers() ) {
      poLine.quantityPU = convertToPU(inv, poLine.quantity)
      await poLine.maybeRefreshQuantity()
    }
  }
  if ( ! await po.hasLines() ) {
    maint.showMessage("There are no sales order lines with quantities remaining to ship")
    return
  }
  await po.generatePOReceipt()
  await po.updateSO()
})

'Add Sales Order Lines'.availableWhen(po => {
  return po.so ? true : false
})

'so'.visibleWhen((maint, po) => {
  return po.so ? true : false
})

'lineExpectedDeliveryDate'.calculateWhen(async poLine => {
  return poLine.separateDelivery !== 'Yes'
})

'lineExpectedDeliveryDate'.calculate(async poLine => {
  let po = poLine.refereeFast('purchaseOrder')
  if ( (! po) || (po === 'na') )
    po = await poLine.referee('purchaseOrder')
  if ( ! po ) return global.emptyYMD()
  return po.expectedDeliveryDate
})

'lineExpectedDeliveryDate'.columnVisibleWhen((maint, po) => {
  return po.hasSeparateDeliveryLines === 'Yes'
})

'lineExpectedDeliveryDate'.readOnlyWhen((maint, poLine) => {
  if ( poLine.lineType && (poLine.lineType !== 'Product') )
    return true
  return poLine.separateDelivery !== 'Yes'
})

'separateDelivery'.columnVisibleWhen((maint, po) => {
  return global.confVal('allowDeliveryDatesOnPOLines') === 'Yes'
})

'separateDelivery'.afterUserChange(async (oldInputValue, newInputValue, poLine) => {
  let po = await poLine.toPO(); if ( ! po ) return

  let defaultDate = async () => {
    let res = po.expectedDeliveryDate
    let lines = await po.toPOLines()
    for ( var i = lines.length - 1; i >= 0; i-- ) {
      let line = lines[i]
      if ( line.id === poLine.id ) continue
      if ( line.separateDelivery !== 'Yes' ) continue
      res = line.lineExpectedDeliveryDate
      break
    }
    return res
  }

  if ( poLine.separateDelivery === 'Yes' )
    poLine.lineExpectedDeliveryDate = await defaultDate()
  await po.refreshHasSeparateDeliveryLines()
})

'PO'.method('refreshHasSeparateDeliveryLines', async function() {
  let lines = await this.toPOLines()
  this.hasSeparateDeliveryLines = 'No'
  for ( var i = 0; i < lines.length; i++ ) {
    let line = lines[i]
    if ( line.separateDelivery === 'Yes' ) {
      this.hasSeparateDeliveryLines = 'Yes'
      break
    }
  }
})

'Payments'.availableWhen(po => {
  return global.confVal('supplierPaymentHandling') === 'Multiple Payments Per PO'
})

'paymentStatus'.readOnlyWhen((maint, po) => {
  return global.confVal('supplierPaymentHandling') === 'Multiple Payments Per PO'
})

'amountOutstandingFX'.visibleWhen((maint, po) => {
  return global.confVal('supplierPaymentHandling') === 'Multiple Payments Per PO'
})

'PO'.method('refreshAmountOutstanding', async function() {
  await this.refreshCalculations({force: true})
  this.amountOutstandingFX = this.costIncTaxFX
  let payments = await 'Payment'.bring({purchaseOrder: this.reference()})
  for ( var i = 0; i < payments.length; i++ ) {
    let payment = payments[i]
    if ( payment.status === 'Unpaid' ) continue
    this.amountOutstandingFX -= payment.amountFX
  }
  if ( global.confVal('supplierPaymentHandling') !== 'Multiple Payments Per PO' ) return
  if ( this.amountOutstandingFX === this.costIncTaxFX )
    this.paymentStatus = 'Unpaid'
  else if ( this.amountOutstandingFX <= 0 )
    this.paymentStatus = 'Paid'
  else
    this.paymentStatus = 'Partially Paid'
})

'priorWeeksSalesUnits'.caption(async maint => {
  let config = 'Configuration'.bringSingleFast(); if ( ! config ) return null
  let priorWeekCount = config.salesProjectionPriorWeeks
  return "Last".translate() + " " + priorWeekCount + " " + "Weeks Sales Units".translate()
})

'priorWeeksSalesValue'.caption(async maint => {
  let config = 'Configuration'.bringSingleFast(); if ( ! config ) return null
  let priorWeekCount = config.salesProjectionPriorWeeks
  return "Last".translate() + " " + priorWeekCount + " " + "Weeks Sales Value".translate()
})

/*
'priorSemiRecentWeeksSalesUnits'.caption(async maint => {
  let config = await 'Configuration'.bringSingleFast(); if ( ! config ) return null
  let priorWeekCount = Math.floor(config.salesProjectionPriorWeeks / 2)
  return "Last".translate() + " " + priorWeekCount + " " + "Weeks Sales".translate()
})

'priorRecentWeeksSalesUnits'.caption(async maint => {
  let config = await 'Configuration'.bringSingleFast(); if ( ! config ) return null
  let priorWeekCount = Math.floor(config.salesProjectionPriorWeeks / 2)
  priorWeekCount = Math.floor(priorWeekCount / 2)
  return "Last".translate() + " " + priorWeekCount + " " + "Weeks Sales".translate()
})
*/

'priorWeeksSalesUnits'.columnVisibleWhen(grid => {
  let c = 'Configuration'.bringSingleFast(); if ( ! c ) return false
  return c.viewSalesHistoryInPurchasing === 'Yes'
})

'priorWeeksSalesValue'.columnVisibleWhen(grid => {
  let c = 'Configuration'.bringSingleFast(); if ( ! c ) return false
  return c.viewSalesHistoryInPurchasing === 'Yes'
})

/*
'priorSemiRecentWeeksSalesUnits'.columnVisibleWhen(grid => {
  let c = 'Configuration'.bringSingleFast(); if ( ! c ) return false
  return c.viewSalesHistoryInPurchasing === 'Yes'
})

'priorRecentWeeksSalesUnits'.columnVisibleWhen(grid => {
  let c = 'Configuration'.bringSingleFast(); if ( ! c ) return false
  return c.viewSalesHistoryInPurchasing === 'Yes'
})
*/

'paymentStatus'.options(['Unpaid', 'Prepayment Required', 'Partially Paid', 'Paid'])

'paymentStatus'.inception('Unpaid')

'paymentDueDate'.inception(global.emptyYMD())

'paymentDueDate'.visibleWhen((maint, po) => {
  let res = po.paymentStatus && (po.paymentStatus !== 'Paid')
  return res
})

'daysUntilPaymentDue'.visibleWhen((maint, po) => {
  return po.paymentStatus && (po.paymentStatus !== 'Paid') && global.ymdIsSet(po.paymentDueDate)
})

'daysUntilPaymentDue'.calculate(po => {
  if ( (! po.paymentDueDate) || (po.paymentDueDate === global.emptyYMD()) )
    return 0
  return - global.todayYMD().dateSubtract(po.paymentDueDate)
})

'Bulk Add'.act(async (maint, po) => {
  let supplier = await po.toSupplier()
  if ( ! supplier ) {
    maint.showMessage("Please select a Supplier first")
    return
  }
  await maint.segue('view', 'BulkAdd.js', po)
})

'quantity'.readOnlyWhen((maint, poLine) => {
  return poLine.purchasingUOMDiffers()
})

'quantityPU'.readOnlyWhen((maint, poLine) => {
  return ! poLine.purchasingUOMDiffers()
})

'quantityPU'.columnVisibleWhen(grid => {
  let c = 'Configuration'.bringSingleFast(); if ( ! c ) return false
  let res = c.showUOMOnPOLines === 'Yes'
  return res
})

'uomDisplay'.columnVisibleWhen(grid => {
  let c = 'Configuration'.bringSingleFast(); if ( ! c ) return false
  let res = c.showUOMOnPOLines === 'Yes'
  return res
})

'pdfTitle'.calculate(po => {
  return 'PURCHASE ORDER'.translate()
})

'pdfLogo'.calculate(async po => {
  let c = await 'Configuration'.bringFirst(); if ( ! c ) return null
  return c.poPdfLogoUrl
})

'businessName'.calculate(async po => {
  let c = await 'Configuration'.bringFirst(); if ( ! c ) return null
  return c.businessName
})

'PO'.method('refreshClumps', async function() {
  let lines = await this.toPOLines()
  for ( var i = 0; i < lines.length; i++ ) {
    let line = lines[i]
    await line.refreshClumps()
  }
})

'PO'.method('toPOLines', async function() {
  return await 'POLine'.bringChildrenOf(this)
})

'receivedDate'.calculate(async po => {
  let rec = await po.toLastPOReceipt(); if ( ! rec ) return global.emptyYMD()
  return rec.receivedDate
})

'dateOfLastReceiptFromThisSupplier'.calculate(async po => {
  let supplier = await po.toSupplier(); if ( ! supplier ) return global.emptyYMD()
  let rec = await supplier.toLastPOReceipt(); if ( ! rec ) return global.emptyYMD()
  return rec.receivedDate
})

'receivedDate'.visibleWhen((maint, po) => {
  return po.receivedDate && (po.receivedDate !== global.emptyYMD())
})

'PO'.method('toLastPOReceipt', async function () {
  let recs = await 'POReceipt'.bring({purchaseOrder: this})
  if ( recs.length === 0 ) return null
  recs.sort((r1, r2) => r1.receivedDate > r2.receivedDate ? 1 : -1)
  return recs[recs.length - 1]
})

'PO'.afterCreating(async function () {
  let c = await 'Configuration'.bringFirst(); if ( ! c ) return
  this.includeTaxOption = c.enterPurchasePricesInclusiveOfTax
})

'lineCostExclTaxFX'.columnVisibleWhen((maint, po) => {
  return po.includeTaxOption === "No"
})

'lineCostIncTaxFX'.columnVisibleWhen((maint, po) => {
  return po.includeTaxOption !== "No"
})

'unitCostExclTaxFX'.columnVisibleWhen((maint, po) => {
  return po.includeTaxOption === "No"
})

'unitCostIncTaxFX'.columnVisibleWhen((maint, po) => {
  return po.includeTaxOption !== "No"
})

'View Receipts'.availableWhen(po => po && po.status !== "Awaiting Delivery")

'costIncTaxFXWithCurrency'.calculate(async po => {
  let currency = po.currency ? (po.currency.keyval + ' ') : ''
  let res = currency + global.numToStringWithXDecimals(po.costIncTaxFX, 2)
  return res
})

'supplier'.afterUserChange(async (oldInputValue, newInputValue, po) => {
  await po.refreshExpectedDeliveryDate()
  let s = await po.toSupplier()
  po.currency = (s && s.currency2) ? s.currency2 : null
  let c = await po.toCurrency()
  po.exchangeRate = c ? c.exchangeRate : 1
})

'supplierCurrency2'.calculate(async po => {
  let s = await po.toSupplier()
  return s ? s.currency2 : null
})

'currency'.visibleWhen((maint, po) => {
  return po.supplierCurrency2 ? true : false
})

'currency'.afterUserChange(async (oldInputValue, newInputValue, po) => {
  let c = await po.toCurrency()
  po.exchangeRate = c ? c.exchangeRate : 1
})

'exchangeRate'.inception(1)

'exchangeRate'.visibleWhen((maint, po) => {
  return po.currency ? true : false
})

'PO'.method('toCurrency', async function() {
  return await this.referee('currency')
})

'stage'.options(['Draft', 'Entered', 'Sent to Supplier', 'Confirmed', 'Goods In Transit', 'Goods Arrived', 'Complete'])

'POMaint'.warning(async (maint, po) => {
  let s = await po.toSupplier(); if ( ! s ) return
  let min = s.minimumOrderValue; if ( ! min ) return
  if ( po.costIncTaxFX >= min ) return
  return "Supplier minimum order value is".translate() + " " + global.numToStringWithXDecimals(min, 2) + 
    " (" + "this order's value is only".translate() + " " + global.numToStringWithXDecimals(po.costIncTaxFX, 2) + ")"
})

'PO'.method("hasLines", async function () {
  let lines = await 'POLine'.bringChildrenOf(this)
  return lines.length > 0
})

'location'.afterUserChange(async (oldInputValue, newInputValue, po) => {
  let hasLines = await po.hasLines()
  if ( hasLines )
    return "Location cannot be altered once purchase order lines have been added"
})

'orderDate'.afterUserChange(async (oldInputValue, newInputValue, po) => {
  await po.refreshExpectedDeliveryDate()
})

'PO'.method('toSupplier', async function() {
  return await this.referee('supplier')
})

'PO'.method('refreshExpectedDeliveryDate', async function() {
  let supplier = await this.referee('supplier'); if ( ! supplier ) return
  if ( ! this.orderDate ) return
  this.expectedDeliveryDate = this.orderDate.incDays(supplier.deliveryLeadDays)
})

'Auto Lines - Min-Max'.act(async (maint, po) => {

  let knt = 0
  let potentials = {}

  let getDefaultTaxPct = async () => {
    let config = await 'Configuration'.bringSingle(); if ( ! config ) return 0
    return config.taxPct
  }

  let addPotential = async (pot) => {
    let inv = await pot.avenue.referee('inventory'); if ( ! inv ) return
    let prodRef = inv.product; if ( ! prodRef ) return
    let prod = await inv.toProduct(); if ( ! prod ) return
    potentials[prodRef.id] = pot
  }

  let calcSales = async () => {
    let orderItems = await 'order_items.RecentOrActive'.bring()
    for ( var i = 0; i < orderItems.length; i++ ) {
      if ( (i % 100) === 0 )
        await global.updateProgress(0.3 + ((i / orderItems.length) * 0.3))
      let orderItem = orderItems[i]
      let status = orderItem.order_status
      if ( (status !== "wc-pending") && (status !== "wc-failed") && (status !== "wc-partially-paid") ) continue
      let varId = orderItem._variation_id
      let productId = varId ? varId : orderItem._product_id
      let pot = potentials[productId]; if ( ! pot ) continue
      if ( ! pot.onSalesOrders )
        pot.onSalesOrders = 0
      pot.onSalesOrders += orderItem._qty
    }
  }

  let convertToPU = (inv, qty) => {
    let ratio = inv.quantityPerPurchasingUOM; if ( ! ratio ) return qty
    return Math.ceil(qty / ratio)
  }

  let createAutoLines = async () => {
    await global.updateProgress(0.05)
    let avenues = await 'Avenue'.bring({supplier: po.supplier})
    let i
    for ( i = 0; i < avenues.length; i++ ) {
      let avenue = avenues[i]
      if ( avenue.isMain !== 'Yes' ) continue
      await addPotential({avenue: avenue})
    }
    await global.updateProgress(0.3)
    await calcSales()
    let currency = await po.toCurrency()
    await global.updateProgress(0.6)
    let len = Object.keys(potentials).length
    i = 0
    for ( var prodId in potentials ) {
      i++
      if ( (i % 100) === 0 )
        await global.updateProgress(0.6 + ((i / len) * 0.4))
      let pot = potentials[prodId]
      let inv = await pot.avenue.referee('inventory'); if ( ! inv ) continue
      if ( ! pot.onSalesOrders )
        pot.onSalesOrders = 0
      let avail = inv.quantityOnHand - pot.onSalesOrders + inv.quantityOnPurchaseOrders
      let surplus = avail - inv.minQuantity
      if ( surplus >= 0 ) continue
      let qty = - surplus
      if ( inv.maxQuantity > 0 )
        qty = inv.maxQuantity - avail
      if ( qty < 1 ) continue
      if ( qty < pot.avenue.minimumOrderQuantity )
        qty = pot.avenue.minimumOrderQuantity
      let poLine = await maint.addChildCast()
      poLine.product = inv.product
      poLine.description = inv.productName
      poLine.taxPct = await getDefaultTaxPct()
      let cost = await inv.getDefaultPurchaseUnitCostIncTax()
      if ( poLine.includeTaxOption === 'Yes' ) {
        poLine.unitCostIncTaxFX = await global.localAmountToForeign(cost, currency)
        poLine.unitCostIncTaxFX = global.roundTo2Decimals(poLine.unitCostIncTaxFX)
      } else {
        let costExclTax = cost / ( 1 + (poLine.taxPct / 100) )
        poLine.unitCostExclTaxFX = await global.localAmountToForeign(costExclTax, currency)
        poLine.unitCostExclTaxFX = global.roundTo2Decimals(poLine.unitCostExclTaxFX)
      }
      poLine.quantity = qty
      poLine.uom = global.copyObj(inv.purchasingUOM)
      await poLine.refreshCalculations({force: true, includeDefers: true})
      if ( poLine.purchasingUOMDiffers() ) {
        poLine.quantityPU = convertToPU(inv, poLine.quantity)
        await poLine.maybeRefreshQuantity()
      }
      if ( poLine.refreshAutoAllotments )
        await poLine.refreshAutoAllotments()
      poLine.refreshIndexes()
      knt++
    }
  }

  if ( ! po.supplier ) {
    maint.showMessage("Please select a Supplier before attempting to generate auto PO lines")
    return
  }
  global.startProgress({message: 'Generating automatic purchase order lines using Min-Max algorithm...'})
  try {
    await createAutoLines()
  } finally {
    global.stopProgress()
  }
  if ( knt === 0 ) {
    maint.showMessage("This supplier isn't the main supplier of any products with available quantity less than the low stock threshold")
    return
  }

})

'overdueDays'.calculate(async (po) => {
  return global.todayYMD().dateSubtract(po.expectedDeliveryDate)
})

'costIncTax'.calculate(async (po) => {
  let lines = await 'POLine'.bringChildrenOf(po)
  let res = 0
  for ( var i = 0; i < lines.length; i++ ) {
    let line = lines[i]
    let lineCostIncTax = await line.calcLineCostIncTax()
    res += lineCostIncTax
  }
  return res
})

'costExclTax'.calculate(async (po) => {
  let lines = await 'POLine'.bringChildrenOf(po)
  let res = 0
  for ( var i = 0; i < lines.length; i++ ) {
    let line = lines[i]
    let lineCostExclTax = await line.calcLineCostExclTax()
    res += lineCostExclTax
  }
  return res
})

'costExclTaxFX'.calculate(async (po) => {
  let lines = await 'POLine'.bringChildrenOf(po)
  let res = 0
  for ( var i = 0; i < lines.length; i++ ) {
    let line = lines[i]
    let lineCostExclTax = await line.calcLineCostExclTaxFX()
    res += lineCostExclTax
  }
  return res
})

'costIncTaxFX'.calculate(async (po) => {
  let lines = await 'POLine'.bringChildrenOf(po)
  let res = 0
  for ( var i = 0; i < lines.length; i++ ) {
    let line = lines[i]
    let lineCostIncTax = await line.calcLineCostIncTaxFX()
    res += lineCostIncTax
  }
  return res
})

'tax'.calculate(async (po) => {
  let lines = await 'POLine'.bringChildrenOf(po)
  let res = 0
  for ( var i = 0; i < lines.length; i++ ) {
    let line = lines[i]
    let lineTax = await line.getLineTaxUnrounded()
    res += lineTax
  }
  return res
})

'taxFX'.calculate(async (po) => {
  let lines = await 'POLine'.bringChildrenOf(po)
  let res = 0
  for ( var i = 0; i < lines.length; i++ ) {
    let line = lines[i]
    let lineTax = await line.getLineTaxFXUnrounded()
    res += lineTax
  }
  return res
})

'supplierFullAddress'.calculate(async (po) => {
  let supplierRef = po.supplier; if ( ! supplierRef ) return null
  let id = supplierRef.id; if ( ! id ) return null
  let supplier = await 'Supplier'.bringSingle({id: supplierRef.id}); if ( ! supplier ) return null
  return supplier.getFullAddress()
})

'POMaint'.whenAdding(async function() {

  let defaultNumber = async () => {
    let res
    while ( true ) {
      let nextNo = await 'NextNumber'.bringOrCreate({forDatatype: 'PO'})
      nextNo.number = nextNo.number + 1
      let noStr = nextNo.number + ""
      res = "PO" + noStr.padStart(5, '0')
      let po = await 'PO'.bringFirst({purchaseOrderNumber: res})
      if ( ! po )
        break
    }
    this.setFieldValue('purchaseOrderNumber', res)
  }

  let defaultDeliverTo = async () => {
    let c = await 'Configuration'.bringSingle(); if ( ! c ) return
    let addr = await c.getFullDeliveryAddress()
    //'deliverTo'.set(addr)
    this.setFieldValue('deliverTo', addr)
  }

  let defaultContact = async () => {
    let c = await 'Configuration'.bringSingle(); if ( ! c ) return
    let res = c.phoneNumber
    if ( c.email ) {
      if ( res )
        res = res + ", "
      res = res + c.email
    }
    //'ourContactDetails'.set(res)
    this.setFieldValue('ourContactDetails', res)
  }

  let maybeDefaultFromSO = async () => {
    let so = this.callerCast(); if ( ! so ) return
    if ( so.datatype() !== 'SO' ) return
    await so.refreshCalculations({force: true})
    let deliverTo = so.shippingNameAndCompany
    deliverTo = global.appendWithSep(deliverTo, so.shippingAddress, ', ')
    this.setFieldValue('deliverTo', deliverTo)
    this.setFieldValue('ourContactDetails', so.shippingEmailAndPhone)
    this.setFieldValue('so', so.reference())
  }

  await defaultNumber()
  await defaultDeliverTo()
  await defaultContact()
  await maybeDefaultFromSO()

})

'status'.inception('Awaiting Delivery')

'location'.inception(async po => {
  let loc = await 'Location'.bringSingle({locationName: 'General'})
  return loc.reference()
})

'PO'.method('refreshStatus', async function() {
  let lines = await 'POLine'.bringChildrenOf(this)
  lines = lines.filter(line => (! line.lineType) || (line.lineType === "Product") || (line.quantity > 0) )
  if ( lines.length === 0 ) {
    this.status = 'Awaiting Delivery'
  } else if ( lines.all(line => (Math.abs(line.quantity) > 0) && Math.abs(line.receivedQuantity + line.cancelledQuantity) >= Math.abs(line.quantity)) ) {
    this.status = 'Received'
  } else if ( lines.none(line => line.receivedQuantity !== 0) ) {
    this.status = 'Awaiting Delivery'
  } else if ( lines.some(line => Math.abs(line.receivedQuantity + line.cancelledQuantity) < Math.abs(line.quantity)) ) {
    this.status = 'Partially Received'
  } else {
    this.status = 'Received'
  }
  await this.refreshClumps()
  await this.refreshAmountOutstanding()
})

'PO'.method('toDateLastItemReceived', async function() {
  let receipts = await 'POReceipt'.bringChildrenOf(this)
  let latestDate
  for ( var i = 0; i < receipts.length; i++ ) {
    let receipt = receipts[i]
    let receivedDate = receipt.receivedDate
    if ( (! latestDate) || (receivedDate > latestDate) )
      latestDate = receivedDate
  }
  return latestDate
})

/*
'PO'.method('toShippingValueIncTax', async function() {
  let lines = await 'POLine'.bringChildrenOf(this)
  let res = 0
  for ( var i = 0; i < lines.length; i++ ) {
    let line = lines[i]
    if ( line.lineType === 'Shipping' )
      res += line.lineCostIncTax
  }
  return res
})

'PO'.method('toFeesAndOtherValueIncTax', async function() {
  let lines = await 'POLine'.bringChildrenOf(this)
  let res = 0
  for ( var i = 0; i < lines.length; i++ ) {
    let line = lines[i]
    if ( (line.lineType === 'Fee') || (line.lineType === 'Other') )
      res += line.lineCostIncTax
  }
  return res
})
*/

'PO'.beforeSaving(async function() {

  let getOrCreateEntry = async () => {
    let sourceAbbrev = 'PO'
    let entryNumber = sourceAbbrev + '-' + this.journaledDate
    let res = await 'Entry'.bringOrCreate({entryNumber: entryNumber})
    res.effectiveDate = this.journaledDate
    res.sourceEffectiveDate = res.effectiveDate
    res.notes = 'Payment ' + res.effectiveDate.toLocalMMMDY()
    res.enteredDate = global.todayYMD()
    return res
  }

  let maybeReverseOldPaymentEntry = async () => {
    if ( ! this.journaledPaymentAmount ) return
    let loc = await this.referee('journaledPaymentLocation')
    await updatePaymentJournalEntry({location: loc, amount: - this.journaledPaymentAmount})
  }

  let updatePaymentJournalEntry = async (options) => {
    if ( ! options.amount ) return
    let entry = await getOrCreateEntry()
    let supplier = await this.toSupplier()
    await entry.updatePurchase(options.location, options.amount, 'Payment', supplier)
  }

  let updatePaymentJournalEntries = async () => {
    await maybeReverseOldPaymentEntry()
    let amount = this.paymentStatus === 'Paid' ? this.costIncTax : 0
    let loc = await this.toLocation()
    await updatePaymentJournalEntry({location: loc, amount: amount})
    this.journaledPaymentAmount = amount
    this.journaledPaymentLocation = loc.reference()
  }

  let updateJournalEntries = async () => {
    let config = await 'Configuration'.bringOrCreate()
    if ( config.glEnabled !== 'Yes' ) return
    if ( config.supplierPaymentHandling === 'Multiple Payments Per PO' ) return
    this.journaledDate = global.todayYMD()
    await updatePaymentJournalEntries()
  }

  let createTransition = async () => {
    if ( global.confVal('ptr') !== 'Yes' ) return
    let old = this.getOld()
    if ( old && (old.stage === this.stage) && (old.status === this.status) )
      return
    let t = await 'Transition'.create(null, {purchaseOrder: this})
    t.oldStage = old ? old.stage : ''
    t.newStage = this.stage
    t.oldStatus = old ? old.status : ''
    t.newStatus = this.status
    t.transitionDate = global.todayYMD()
    t.transitionTime = global.nowHMS()
    t.user = global.gApp.user // this is a reference
  }

  if ( (this.status !== 'Awaiting Delivery') && this.location && this.old && this.old.location && this.propChanged('location') ) {
    throw(new Error("You cannot change the location on an order that has been received or partially received".translate()))
  }
  let old = this.getOld()
  if ( this.expectedDeliveryDate ) {
    if ( this.isNew() || (! old) || (this.expectedDeliveryDate !== old.expectedDeliveryDate) )
      await this.refreshNextExpectedDeliveryDates()
  }
  if ( this.isNew() || (! old) || (this.stage !== old.stage) || (this.status !== old.status) ) {
    await this.refreshQuantitiesOnPurchaseOrders()
  }
  if ( this.isNew() || (! old) || (this.exchangeRate !== old.exchangeRate) )
    await this.refreshLastPurchases()
  await this.refreshAmountOutstanding()
  if ( this.so ) {
    await this.generatePOReceipt()
    await this.updateSO()
  } else {
    await this.maybeAutoReceive()
  }
  await updateJournalEntries()
  await createTransition()
})

'PO'.method('maybeAutoReceive', async function() {
  if ( await this.hasProducts() ) return
  await this.generatePOReceipt()
})

'PO'.method('toAmountOnReceipts', async function() {
  let rec; let recs = await 'POReceipt'.bring({purchaseOrder: this})
  let res = 0
  while ( rec = recs.__() ) {
    res += await rec.toCost()
  }
  return res
})

'PO'.method('toAmountPaid', async function() {
  let p; let ps = await this.toPayments()
  let res = 0
  while ( p = ps.__() ) {
    let payAmtFX = await p.toPaidAmountFX()
    let payAmt = payAmtFX / this.exchangeRate
    res += payAmt
  }
  return res
})

'PO'.method('toPayments', async function() {
  return await 'Payment'.bring({purchaseOrder: this.reference()})
})


'PO'.method('hasProducts', async function() {
  let line; let lines = await this.toPOLines()
  while ( line = lines.__() ) {
    if ( line.lineType && (line.lineType !== "Product") )
      continue
    return true
  }
  return false
})

'PO'.method('refreshQuantitiesOnPurchaseOrders', async function() {
  let lines = await this.toPOLines()
  for ( var i = 0; i < lines.length; i++ ) {
    let line = lines[i]
    await line.refreshClumps()
    let inv = await line.toInventory(); if ( ! inv ) continue
    await inv.refreshQuantityOnPurchaseOrders()
  }
})

'PO'.method('refreshNextExpectedDeliveryDates', async function() {
  let lines = await this.toPOLines()
  for ( var i = 0; i < lines.length; i++ ) {
    let line = lines[i]
    let inv = await line.toInventory(); if ( ! inv ) continue
    await inv.refreshNextExpectedDeliveryDate()
  }
})

'PO'.method('refreshLastPurchases', async function() {
  let lines = await this.toPOLines()
  for ( var i = 0; i < lines.length; i++ ) {
    let line = lines[i]
    let inv = await line.toInventory(); if ( ! inv ) continue
    await inv.refreshLastPurchase()
  }
})

'Download PDF'.act(async (maint, po) => {
  maint.downloadPDF({spec: "POPdf.js", docName: po.purchaseOrderNumber + ".PDF"})
})

'Download CSV'.act(async (maint, po) => {
  maint.downloadCSV({spec: "POCsv.js", docName: po.purchaseOrderNumber + ".CSV"})
})

'POMaint'.makeDestinationFor('PO')

'descriptionAndSKU'.destination(async poLine => {
  if ( poLine.lineType === 'Product' )
    return await poLine.toProduct()
  return poLine
})

'PO'.method('toLocation', async function() {
  let res = await this.referee('location')
  return res
})

'PO'.method('toLocationName', async function() {
  let loc = await this.toLocation(); if ( ! loc ) return 'General'
  let res = loc.locationName
  if ( ! res )
    res = 'General'
  return res
})

